
## AOP导言

<br>

* OOP(面向对象编程)针对业务处理过程的实体及其属性和行为进行抽象封装, 以获得更加清晰高效的逻辑单元划分
* AOP针对业务处理过程中的切面进行提取, 它所面对的是处理过程中的某个步骤或阶段, 以获得逻辑过程中各部分之间低耦合性的隔离效果
* 一些OO设计模式解决了AOP希望解决的部分问题:
1) Decorator(装饰器)模式
2) Observer(观察者)模式
3) Chain of Responsibility (责任链)模式

* Spring AOP构建于IoC之上, 和IoC浑然天成统一于Spring容器中
* AOP代理是AOP框架创建的对象, AOP在JavaEE应用开发中的价值在于为业务对象提供代理
* Spring有两种代理方式
1) 默认使用J2SE动态代理实现AOP代理, 主要用于代理接口
2) CGLIB代理, 实现类的代理, 而不是接口
* Spring重点关注AOP的一个子集: 方法拦截(method interception)
* AOP实现策略:
1) J2SE动态代理 (JDK1.3引入动态代理dynamic proxies, 局限, 只能针对接口, 不能针对类)
2) 动态字节码生成 (CGLIB Code Generation Library工具, 可针对类提供代理)
3) Java代码生成 (不再流行)
4) 使用定制的类加载器 (改变new操作符行为, 偏离Java标准)
5) 语言扩展 (AspeetJ)

<br>

## 定义AOP术语

<br>

* Aspect(切面): 横切关注点的抽象即切面, 与类相似, 只是两者的关注点不一样 类是对物体特征的抽象, 而切面是横切关注点的抽象
* joinpoint(连接点): 所谓连接点是指那些被拦截到的点. 在Spring中, 这些点指的是方法, 因为spring只支持方法类型的连接点, 实际上joinpoint还可以是field或类构造器
* Pointcut(切入点): 所谓切入点是指我们要对哪些joinpoint进行拦截的定义
* Advice(通知): 所谓通知是指拦截到joinpoint之后所要做的事情. 通知分为前置通知Before, 后置通知After, 异常通知After-throwing, 最终通过After-returning, 环绕通知Around
* Advisor(通知器): Spring引入的更抽象的概念, 由两部分组成: 一个通知Advice和一个用于说明, "在何处进行通知" 的切入点. 通知器完整模块化了一个切面. 这样, 切入点和通知也可以各自独立地复用
* Target(目标对象): 代理的目标对象
* Weave(织入): 指将aspects应用到target对象并导致proxy对象创建的过程
1) 在目标对象的生命周期中有多个点可以进行织入: 编译期, 类加载期, 运行期
* Introduction(引入): 在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field
* Interceptor(拦截器): 很多AOP框架用它来实现字段和方法的拦截, 随之而来的就是在连接点处挂接一条拦截器链, 链条上的每个拦截器通常会调用下一个拦截器. 实际上, 拦截时一种AOP的实现策略
* AOP代理(AOP proxy): 即被通知的对象引用 - 也就是说, AOP通知将在其上执行的这样一个对象引用. 对于基于拦截的AOP框架来说, AOP代理概念极为关键. AOP代理可能是J2SE的动态代理, 也可能是借助字节码操作工具生成的

<br>

## Spring对AOP的支持

<br>

* AOP框架的基本功能: 创建切入点来定义切面织入得连接点
* AOP框架领域三足鼎立:
1) AspectJ
2) JBoss AOP
3) Spring AOP

* Spring提供4种各具特色的AOP支持:
1) 经典的Spring基于代理AOP
2) @AspectJ注解驱动的切面
3) 纯POJO切面
4) 注入式AspectJ切面

* 当引入简单的声明式AOP和基于注解的AOP之后, 直接使用ProxyFactoryBean的经典Spring AOP就过时了

* Spring AOP框架的关键点:
1) Spring通知是用Java编写的, 定义通知所应用的切面通常在Spring配置文件中用XML编写
2) Spring在运行期间通知对象通过使用代理类, Spring在运行期间将切面织入Spring管理的Bean中
3) Spring只支持方法的拦截

* 切入点, 通知, 横切关注点等在权限系统中的技术实现

